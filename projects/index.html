<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><style>:root{--accent-color:#FF4D4D}</style><title>Projects</title>
<meta name=description content="Below you&rsquo;ll find some of the top things stealing lots of time from my social life ðŸ¤“. There&rsquo;s loads more than what&rsquo;s here, both my projects â€¦"><meta name=keywords content><meta property="og:url" content="https://followtheprocess.github.io/projects/"><meta property="og:type" content="website"><meta property="og:title" content="Projects"><meta property="og:description" content="Below you&rsquo;ll find some of the top things stealing lots of time from my social life ðŸ¤“. There&rsquo;s loads more than what&rsquo;s here, both my projects â€¦"><meta property="og:image" content="https://followtheprocess.github.io/images/profile.jpg"><meta property="og:image:secure_url" content="https://followtheprocess.github.io/images/profile.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Projects"><meta name=twitter:description content="Below you&rsquo;ll find some of the top things stealing lots of time from my social life ðŸ¤“. There&rsquo;s loads more than what&rsquo;s here, both my projects â€¦"><meta property="twitter:domain" content="https://followtheprocess.github.io/projects/"><meta property="twitter:url" content="https://followtheprocess.github.io/projects/"><meta name=twitter:image content="https://followtheprocess.github.io/images/profile.jpg"><link rel=canonical href=https://followtheprocess.github.io/projects/><link rel=stylesheet type=text/css href=/css/normalize.min.css media=print><link rel=stylesheet type=text/css href=/css/main.min.css><link id=dark-theme rel=stylesheet href=/css/dark.min.css><script src=/js/bundle.min.9a920d7dabdbad8363b6a0a94e29a9dfebdb7ee64cfcb193a0145e512ef2bdab.js integrity="sha256-mpINfavbrYNjtqCpTimp3+vbfuZM/LGToBReUS7yvas="></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css integrity=sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js integrity=sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><script>setThemeByUserPref()</script><header class=header><nav class=header-nav><div class=avatar><a href=https://followtheprocess.github.io/><img src=/images/profile.jpg alt=avatar></a></div><div class=nav-title><a class=nav-brand href=https://followtheprocess.github.io/>@FollowTheProcess</a></div><div class=nav-links><div class=nav-link><a href=https://followtheprocess.github.io/>Home</a></div><div class=nav-link><a href=https://followtheprocess.github.io/posts/>Posts</a></div><div class=nav-link><a href=https://followtheprocess.github.io/projects/>Projects</a></div><div class=nav-link><a href=https://followtheprocess.github.io/cv/>CV</a></div><div class=nav-link><a href=https://github.com/FollowTheProcess/><span data-feather=github></span></a></div><span class=nav-icons-divider></span><div class="nav-link dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target"></span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></div><div class=nav-link id=hamburger-menu-toggle><span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
<a><span data-feather=menu></span></a></div><ul class="nav-hamburger-list visibility-hidden"><li class=nav-item><a href=https://followtheprocess.github.io/>Home</a></li><li class=nav-item><a href=https://followtheprocess.github.io/posts/>Posts</a></li><li class=nav-item><a href=https://followtheprocess.github.io/projects/>Projects</a></li><li class=nav-item><a href=https://followtheprocess.github.io/cv/>CV</a></li><li class=nav-item><a href=https://github.com/FollowTheProcess/><span data-feather=github></span></a></li><li class="nav-item dark-theme-toggle"><span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
<a><span class=theme-toggle-icon data-feather=moon></span></a></li></ul></div></nav></header><main id=content><div class="post container"><div class=post-header-section><h1>Projects</h1></div><div class=post-content><p>Below you&rsquo;ll find some of the top things stealing lots of time from my social life ðŸ¤“. There&rsquo;s loads more than what&rsquo;s here, both my projects and other open source stuff I help maintain, but I didn&rsquo;t want to bore! ðŸ˜´</p><p>Check out my <a href=https://github.com/FollowTheProcess>GitHub</a> if you&rsquo;re interested.</p><p>My favourite things to work on are:</p><ul><li>CLIs</li><li>Developer tooling</li><li>Automation</li><li>Things useful for myself</li><li>All of the above!</li></ul><h2 id=spok><a href=https://github.com/FollowTheProcess/spok>spok</a></h2><p>Spok is a modern, concurrent task runner/build system written in Go.</p><p>It uses it&rsquo;s own hand written declarative language to create tasks and declare dependencies between them, or on files on disk. I&rsquo;m particularly
proud of the lexer and parser as the lexer is a novel state-based approach which runs concurrently with the parser passing tokens around
using go channels.</p><p>Another highlight for me is the performance of the file hashing, spok can hash a deeply nested directory tree containing thousands
of files in ~300ms.</p><p>Improvements over make include:</p><ul><li>Much cleaner, more developer friendly syntax</li><li>Tasks (make: targets) are run concurrently by default (unless dependencies preclude)</li><li>Built in support for glob patterns</li><li>Full cross-compatibility, tested on mac, linux and windows</li><li>Incremental runs based on file dependency hashing and checksums not OS timestamps</li><li>Automatic loading of <code>.env</code> files</li><li>A VSCode extension providing syntax highlighting, task exploration etc.</li></ul><p>An example of spok&rsquo;s syntax:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Comments are preceded by a hash</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># You can store global variables like this (caps are optional)</span>
</span></span><span style=display:flex><span>GLOBAL_VARIABLE <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>BIN <span style=color:#ff7b72;font-weight:700>:=</span> <span style=color:#a5d6ff>&#34;./bin/main&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># You can store the output of a shell command as a variable</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># leading and trailing whitespace will always be trimmed off when doing this</span>
</span></span><span style=display:flex><span>GIT_COMMIT <span style=color:#ff7b72;font-weight:700>:=</span> exec(<span style=color:#a5d6ff>&#34;git rev-parse HEAD&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Use a global variable like this</span>
</span></span><span style=display:flex><span>task hello() {
</span></span><span style=display:flex><span>    echo {{<span style=color:#ff7b72;font-weight:700>.</span>GLOBAL_VARIABLE}}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Run the go tests (depends on all go source files)</span>
</span></span><span style=display:flex><span>task test(<span style=color:#a5d6ff>&#34;**/*.go&#34;</span>) {
</span></span><span style=display:flex><span>    go test <span style=color:#ff7b72;font-weight:700>./...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Format the project source code (depends on all go source files)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># if the go source files have not changed, this becomes a no op</span>
</span></span><span style=display:flex><span>task fmt(<span style=color:#a5d6ff>&#34;**/*.go&#34;</span>) {
</span></span><span style=display:flex><span>    go fmt <span style=color:#ff7b72;font-weight:700>./...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Compile the program (depends on fmt, fmt will run first)</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># also outputs a build binary</span>
</span></span><span style=display:flex><span>task build(fmt) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#a5d6ff>&#34;./bin/main&#34;</span> {
</span></span><span style=display:flex><span>    go build
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Can also use global variables as outputs</span>
</span></span><span style=display:flex><span>task build2(fmt) <span style=color:#ff7b72;font-weight:700>-&gt;</span> BIN {
</span></span><span style=display:flex><span>    go build
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Tasks can generate multiple things</span>
</span></span><span style=display:flex><span>task many(<span style=color:#a5d6ff>&#34;**/*.go&#34;</span>) <span style=color:#ff7b72;font-weight:700>-&gt;</span> (<span style=color:#a5d6ff>&#34;output1.go&#34;</span>, <span style=color:#a5d6ff>&#34;output2.go&#34;</span>) {
</span></span><span style=display:flex><span>    go do many things
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Can also do glob outputs</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># e.g. tasks that populate entire directories like building documentation</span>
</span></span><span style=display:flex><span>task glob(<span style=color:#a5d6ff>&#34;docs/src/*.md&#34;</span>) <span style=color:#ff7b72;font-weight:700>-&gt;</span> <span style=color:#a5d6ff>&#34;docs/build/*.html&#34;</span> {
</span></span><span style=display:flex><span>    build docs
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Can register a default task (by default spok will list all tasks)</span>
</span></span><span style=display:flex><span>task default() {
</span></span><span style=display:flex><span>    echo <span style=color:#a5d6ff>&#34;default&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Can register a custom clean task</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># By default `spok --clean` will remove all declared outputs</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># if a task called &#34;clean&#34; is present in the spokfile</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># this task will be run instead when `--clean` is used</span>
</span></span><span style=display:flex><span>task clean() {
</span></span><span style=display:flex><span>    rm <span style=color:#ff7b72;font-weight:700>-</span>rf somedir
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=pytoil><a href=https://github.com/FollowTheProcess/pytoil>pytoil</a></h2><p>pytoil is a helpful CLI to take the toil out of software development!</p><p>It seamlessly lets you work with your development projects whether they are on your local machine,
or on GitHub.</p><p>In a nutshell you can:</p><ul><li>Open up a project regardless of where it is with a single command</li><li>Fuzzy text search your repos to find matching projects</li><li>Sync your local development directory with your GitHub in seconds</li><li>Automatically detect appropriate python virtual environments on clone and set them up in the background</li><li>And loads more, check out the <a href=https://followtheprocess.github.io/pytoil/>docs</a></li></ul><p><img src=https://github.com/FollowTheProcess/pytoil/raw/main/docs/img/help.svg alt=help></p><p><strong>Highlights:</strong></p><ul><li>Beautiful CLI powered by <a href=https://click.palletsprojects.com/en/8.0.x/>click</a> and <a href=https://rich.readthedocs.io/en/stable/introduction.html>rich</a></li><li>Optimised performance and memory use, on my machine the CLI starts up in about 200ms (pretty good for a python interpreter!)</li><li>Interacts with the GitHub GraphQL API to fetch only the data it needs</li><li>API requests are cached with a configurable timeout for maximum responsiveness</li><li>Glues together various python development tools (virtualenv, conda, poetry, flit, git, VSCode etc.)</li><li>Bulk actions like cloning/deleting lots of projects are done in a threadpool</li><li>High test coverage and great <a href=https://followtheprocess.github.io/pytoil/>docs</a></li></ul><h2 id=tag><a href=https://github.com/FollowTheProcess/tag>tag</a></h2><p>tag is a CLI to help automate semantic version releases and GitOps.</p><p>With tag you can easily create, delete, sort and push git semver tags. It&rsquo;s written in Go including a
hand-rolled, robust semantic version parser.</p><p><strong>Highlights:</strong></p><ul><li>Simple, intuitive CLI</li><li>Understands semantic versioning, <code>tag minor</code> bumps the minor version etc.</li><li>Can push tags with a single flag: <code>tag patch --push</code> will push a new patch tag to the origin repo</li><li>Supports the full range of semantic versions, including build tags and post releases</li><li>Tag releases itself, it&rsquo;s recursive!</li></ul><p>PS. If someone knows how to use asciicinema or equivalent to record great terminal gifs get in touch, I&rsquo;ve tried a few times
but can never get it to work properly! ðŸ˜‚</p><h2 id=msg><a href=https://github.com/FollowTheProcess/msg>msg</a></h2><p>Continuing the theme of CLIs targeted at developers&mldr; msg is a lightweight terminal printing toolkit for authors
of CLI programs written in Go.</p><p>It enables very easy, very pretty output with a very familiar Go <code>printf</code> interface.</p><p>This:</p><p><img src=https://github.com/FollowTheProcess/msg/raw/main/img/demo.png alt=msg-demo></p><p>Gets you this:</p><p><img src=https://github.com/FollowTheProcess/msg/raw/main/img/demo-output.png alt=msg-demo-output></p><p>I&rsquo;ve dogfooded msg into most of my other Go CLIs and it works great!</p><p><strong>Highlights</strong></p><ul><li>Simple, intuitive API</li><li>Has an <code>Fprint</code> API so you can write to any <code>io.Writer</code></li><li>No fuss, just works!</li></ul><h2 id=py><a href=https://github.com/FollowTheProcess/py>py</a></h2><p>A port of Brett Cannon&rsquo;s excellent <a href=https://github.com/brettcannon/python-launcher>python-launcher</a> to Go, with some experimentation thrown in for good measure.</p><p>Does all the things the original does i.e. all you have to do is run <code>py</code> and it will find the
python interpreter you almost certainly want to use:</p><p><img src=https://github.com/FollowTheProcess/py/raw/main/docs/img/demo.png alt=py-demo></p><p>The few experimental tweaks I&rsquo;ve made:</p><ul><li>This one also finds virtual environments named <code>venv</code> not just <code>.venv</code> (even though I prefer the latter)</li><li>This one won&rsquo;t let you do anything with python2, it completely ignores any python 2 interpreter it finds</li><li>It won&rsquo;t climb the file tree searching for <code>.venv</code> it just looks in <code>$CWD</code></li></ul><p>I was actually quite impressed that it gets very close to the performance of the original (written in rust), especially
considering I&rsquo;ve made no real effort to optimise it!</p><p><img src=https://raw.githubusercontent.com/FollowTheProcess/py/main/docs/img/comp.png alt=py-benchmark></p><ul><li><strong>Left:</strong> My version, written in Go</li><li><strong>Right:</strong> The original, written in Rust</li></ul><p>I&rsquo;ve also kept the nice support for ancillary dev tools like shell prompts etc:</p><p><img src=https://github.com/FollowTheProcess/py/raw/main/docs/img/starship_demo.png alt=py-starship></p><h2 id=goignore><a href=https://github.com/FollowTheProcess/goignore>goignore</a></h2><p>Generate great <code>.gitignore</code> files straight from the command line!</p><p>Goignore is a super small, super simple project, but one that I find very useful and I use it
more or less every day.</p><p>This:</p><p><img src=/images/projects/goignore/goignore_demo.png alt=goignore-demo></p><p>Gets you this:</p><p><img src=/images/projects/goignore/gitignore.png alt=gitignore></p><p>PS. Goignore was actually the first proper program I ever wrote in Go!</p><h2 id=fatigue-damage-prediction><a href=https://github.com/FollowTheProcess/msc_project>Fatigue Damage Prediction</a></h2><p>This was not so much a developer project but my masters thesis, obviously I&rsquo;m not working on it any more (I passed ðŸ¤“) but I figured I&rsquo;d include it here because it&rsquo;s actually
pretty cool, and is the last remnants of a previous life in materials science!</p><p><em>Using machine learning to predict fatigue crack growth under complex thermomechanical loads. Achieved a damage severity predicive accuracy of Â±0.25mm and a positional predictive accuracy of Â±7.0mm.</em></p><h3 id=background>Background</h3><p>Repeated cyclic loading of a material will eventually lead to a phenomenon called &ldquo;fatigue crack growth&rdquo;. I&rsquo;m not going to explain the details here but I&rsquo;d point you to <a href=https://en.wikipedia.org/wiki/Fatigue_(material)>this</a> for more info. Essentially, a crack will start to form and repeated cyclic loading will progressively grow this crack until it is large enough such that the remaining material can no longer handle the stress and the component will break.</p><p>Ever since the <a href=https://en.wikipedia.org/wiki/De_Havilland_Comet#Accidents_and_incidents>comet disasters</a> in the 1950&rsquo;s, understanding exactly how this process works and predicting how long (or more accurately: how many cycles) components can survive for has been a crucial part of the design process. This is done with the so-called Paris Law (although in reality, it&rsquo;s a lot more complicated than this theoretical abstraction).</p><p>$$da/dN = C(\Delta K)^m$$</p><p>Where da is the increment in crack length, dN is the increment in number of cycles, C and m are material-specific constants and Delta K is the increment in stress intensity factor (effectively a way of accounting for the increased stress around a defect such as a crack).</p><p>Pure loading fatigue is very well understood nowadays. However, when you combine fatigue crack growth with other environmental effects such as corrosion, thermal cycling etc. this can result in very unpredictable behaviour.</p><p>The aim of this project was to understand how one of these combinations (fatigue and thermal effects) could be better understood with the application of machine learning.</p><p>Experimental data on the effect of crack propagation on dynamic response (vibration) was generated in a series of earlier experiments on two different materials and given to me to work with for my MSc Advanced Materials thesis project in Spring 2020.</p><p><img src=/images/projects/msc_project/dynamic_response_by_material.png alt="Dynamic Response"></p><p>Starting notches were machined into test specimens which were then vibrated at their natural frequencies at a variety of temperatures. The cracks were then allowed to grow whilst natural frequency and amplitude measurements were continuously taken in order to determine the effect of crack propagation on dynamic properties.</p><p>The objectives of this work were to:</p><ul><li><p>Build a predictive model capable of accurately predicting damage severity and location from a simple vibration test.</p></li><li><p>Use the introspection of the model to attempt to inform the fundamental underlying theory</p></li></ul><h3 id=results>Results</h3><p>After using <a href=https://mlflow.org>mlflow</a> to record parameters and shortlist promising models, I chose a Ridge-regularised multiple Linear Regression model with a polynomial kernel to enable easy introspection as this was a key objective of the project.</p><p>The models were able to predict the depth of the crack with high accuracy (shown below) for both materials.</p><table><thead><tr><th style=text-align:center>Material</th><th style=text-align:center>RMSE</th><th style=text-align:center>$R^2$</th></tr></thead><tbody><tr><td style=text-align:center>Aluminium</td><td style=text-align:center>0.176 mm</td><td style=text-align:center>0.95</td></tr><tr><td style=text-align:center>ABS</td><td style=text-align:center>0.256 mm</td><td style=text-align:center>0.86</td></tr></tbody></table><p><img src=/images/projects/msc_project/combined_accuracy_altair.png alt="Model Accuracy"></p><p>Traditionally in engineering, data of this sort is usually fed into something like matlab and subject to curve fitting. This was done on this data as a benchmark against which to judge the ML model&rsquo;s accuracy. Below is a comparison of the RMSE between traditional polynomial curve fitting in matlab, and the ridge-regularised multiple linear regression model used in this project.</p><p><img src=/images/projects/msc_project/ml_vs_curve_fitting.png alt="Comparison vs Curve Fitting"></p><p>As you can see, the ML model significantly outperformed the traditional polynomial curve fitting method, shaving over 0.6mm off the average prediction error.</p><p>The predictions for Aluminium were also more accurate than those for ABS, the reduced accuracy for the ABS being explained by the anisotropic structure and stress crazing at the crack tip caused by the method of manufacture of the test specimens (FDM additive manufacturing).</p><h3 id=feature-importance>Feature Importance</h3><p>A key part of the project was to understand the underlying factors behind these effects, rather than simply generate predictions. Hence the earlier decision to use a linear model as it&rsquo;s coefficients could be easily inspected.</p><p>A feature importance study was conducted, results shown below.</p><p><img src=/images/projects/msc_project/relative_importance_in_crack_depth_prediction.png alt="Feature Importance"></p><p>The data show that the natural frequency was the most important predictor for both materials. Temperature and crack position were shown to be comparatively less important - an interesting finding.</p><p>In fact, the comparatively low importance of crack position in the prediction of crack depth allowed me to pull crack position out of the feature pool entirely and predict it alongside crack depth and only sacrifice a small amount of accuracy (shown below).</p><p><img src=/images/projects/msc_project/multi_output_accuracy.png alt="Multi Output Prediction"></p><p>The end result was a model that could predict the severity of a thermomechanical fatigue crack to within Â±0.22mm and simultaneously predict its position in the component to within Â±7.0mm, an incredibly powerful result!</p><p><img src=/images/projects/msc_project/multi_output_crack_depth.png alt="Multi Output Crack Depth"></p><h3 id=further-information>Further Information</h3><p>This work was submitted for publication in the academic journal <a href=https://www.mdpi.com/journal/sensors>MDPI Sensors</a> and was accepted and published on 30/11/2020. Full text available <a href=https://www.mdpi.com/1424-8220/20/23/6847>here</a></p><p>[1] Fleet, T.; Kamei, K.; He, F.; Khan, M.A.; Khan, K.A.; Starr, A. A Machine Learning Approach to Model Interdependencies between Dynamic Response and Crack Propagation. Sensors 2020, 20, 6847. <a href=https://doi.org/10.3390/s20236847>https://doi.org/10.3390/s20236847</a></p></div></div></main><footer class=footer><span>&copy; 2024 Tom Fleet</span>
<span>Made with &#10084;&#65039; using <a target=_blank href=https://github.com/526avijitgupta/gokarna>Gokarna</a></span></footer></body></html>