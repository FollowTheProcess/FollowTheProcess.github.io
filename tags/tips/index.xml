<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tips on @FollowTheProcess</title><link>https://followtheprocess.github.io/tags/tips/</link><description>Recent content in Tips on @FollowTheProcess</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 26 Oct 2021 22:05:11 +0100</lastBuildDate><atom:link href="https://followtheprocess.github.io/tags/tips/index.xml" rel="self" type="application/rss+xml"/><item><title>Self Documenting Makefile</title><link>https://followtheprocess.github.io/posts/makefile/</link><pubDate>Tue, 26 Oct 2021 22:05:11 +0100</pubDate><guid>https://followtheprocess.github.io/posts/makefile/</guid><description>&lt;p>If you aren&amp;rsquo;t familiar with &lt;a href="https://www.gnu.org/software/make/">make&lt;/a>, it&amp;rsquo;s a command runner and build system capable of quite complicated stuff. It&amp;rsquo;s syntax can get complicated for non-trivial workflows and it has lots of weird quirks (like &lt;code>.PHONY&lt;/code>).&lt;/p>
&lt;p>However, it&amp;rsquo;s ubiquitous on nearly all systems and pretty easy to get going with so it&amp;rsquo;s very widely used in all sorts of projects in just about every language.&lt;/p>
&lt;p>In fact, a filename global search on GitHub yields an astonishing 112 million results!&lt;/p></description></item><item><title>Just > Make</title><link>https://followtheprocess.github.io/posts/just/</link><pubDate>Sun, 24 Oct 2021 10:22:23 +0100</pubDate><guid>https://followtheprocess.github.io/posts/just/</guid><description>&lt;p>Makefiles (&lt;a href="https://www.gnu.org/software/make/">GNU Make&lt;/a>) are ubiquitous in software development and they are a fantastically useful tool! But for all but the simplest tasks, the syntax can get very unreadable and messy.&lt;/p>
&lt;p>Some programs like complex C or C++ projects will use Makefiles as the full build system it was designed to be, however most people tend to use Makefiles as simple task runners.&lt;/p>
&lt;p>Consider the following example for a simple Go project:&lt;/p></description></item><item><title>Using FieldsFunc in Go</title><link>https://followtheprocess.github.io/posts/fieldsfunc/</link><pubDate>Fri, 22 Oct 2021 20:34:50 +0100</pubDate><guid>https://followtheprocess.github.io/posts/fieldsfunc/</guid><description>&lt;p>I&amp;rsquo;ve been playing with Go a lot recently, and one thing it lends itself &lt;strong>really&lt;/strong> well to is CLIs (Command Line Interfaces):&lt;/p>
&lt;ul>
&lt;li>Runs very fast, feels snappy to use&lt;/li>
&lt;li>Standalone, statically linked binary - easy to distribute&lt;/li>
&lt;li>Easy cross-compilation for multiple platforms, OS&amp;rsquo;s and processor architectures&lt;/li>
&lt;li>Excellent libraries for creating CLIs e.g. &lt;a href="https://github.com/spf13/cobra">cobra&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>The excellent &lt;a href="https://github.com/cli/cli">GitHub CLI&lt;/a> is written in Go 👏🏻&lt;/p>
&lt;p>So needless to say, I&amp;rsquo;ve been writing more than a few CLIs: &lt;a href="https://github.com/FollowTheProcess/gotoil">gotoil&lt;/a>, &lt;a href="https://github.com/FollowTheProcess/tag">tag&lt;/a>, &lt;a href="https://github.com/FollowTheProcess/goignore">goignore&lt;/a> etc&amp;hellip;&lt;/p></description></item></channel></rss>