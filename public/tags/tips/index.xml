<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tips on @FollowTheProcess</title>
    <link>http://localhost:1313/tags/tips/</link>
    <description>Recent content in Tips on @FollowTheProcess</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 26 Oct 2021 22:05:11 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/tips/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Self Documenting Makefile</title>
      <link>http://localhost:1313/posts/makefile/</link>
      <pubDate>Tue, 26 Oct 2021 22:05:11 +0100</pubDate>
      <guid>http://localhost:1313/posts/makefile/</guid>
      <description>&lt;p&gt;If you aren&amp;rsquo;t familiar with &lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;make&lt;/a&gt;, it&amp;rsquo;s a command runner and build system capable of quite complicated stuff. It&amp;rsquo;s syntax can get complicated for non-trivial workflows and it has lots of weird quirks (like &lt;code&gt;.PHONY&lt;/code&gt;).&lt;/p&gt;&#xA;&lt;p&gt;However, it&amp;rsquo;s ubiquitous on nearly all systems and pretty easy to get going with so it&amp;rsquo;s very widely used in all sorts of projects in just about every language.&lt;/p&gt;&#xA;&lt;p&gt;In fact, a filename global search on GitHub yields an astonishing 112 million results!&lt;/p&gt;</description>
    </item>
    <item>
      <title>Just &gt; Make</title>
      <link>http://localhost:1313/posts/just/</link>
      <pubDate>Sun, 24 Oct 2021 10:22:23 +0100</pubDate>
      <guid>http://localhost:1313/posts/just/</guid>
      <description>&lt;p&gt;Makefiles (&lt;a href=&#34;https://www.gnu.org/software/make/&#34;&gt;GNU Make&lt;/a&gt;) are ubiquitous in software development and they are a fantastically useful tool! But for all but the simplest tasks, the syntax can get very unreadable and messy.&lt;/p&gt;&#xA;&lt;p&gt;Some programs like complex C or C++ projects will use Makefiles as the full build system it was designed to be, however most people tend to use Makefiles as simple task runners.&lt;/p&gt;&#xA;&lt;p&gt;Consider the following example for a simple Go project:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Using FieldsFunc in Go</title>
      <link>http://localhost:1313/posts/fieldsfunc/</link>
      <pubDate>Fri, 22 Oct 2021 20:34:50 +0100</pubDate>
      <guid>http://localhost:1313/posts/fieldsfunc/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been playing with Go a lot recently, and one thing it lends itself &lt;strong&gt;really&lt;/strong&gt; well to is CLIs (Command Line Interfaces):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Runs very fast, feels snappy to use&lt;/li&gt;&#xA;&lt;li&gt;Standalone, statically linked binary - easy to distribute&lt;/li&gt;&#xA;&lt;li&gt;Easy cross-compilation for multiple platforms, OS&amp;rsquo;s and processor architectures&lt;/li&gt;&#xA;&lt;li&gt;Excellent libraries for creating CLIs e.g. &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;cobra&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The excellent &lt;a href=&#34;https://github.com/cli/cli&#34;&gt;GitHub CLI&lt;/a&gt; is written in Go üëèüèª&lt;/p&gt;&#xA;&lt;p&gt;So needless to say, I&amp;rsquo;ve been writing more than a few CLIs: &lt;a href=&#34;https://github.com/FollowTheProcess/gotoil&#34;&gt;gotoil&lt;/a&gt;, &lt;a href=&#34;https://github.com/FollowTheProcess/tag&#34;&gt;tag&lt;/a&gt;, &lt;a href=&#34;https://github.com/FollowTheProcess/goignore&#34;&gt;goignore&lt;/a&gt; etc&amp;hellip;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
